<h1>Autocomplete</h1>
<p>Special text input used for offering matching results or suggestions.</p>
<h2 id="demo">Demo</h2>
<code-sample>
<template>
  <fieldset>
    <label>Search</label>
    <m-autocomplete source="fruit"></m-autocomplete>
  </fieldset>
</template>
</code-sample>
<h2 id="api">API</h2>
<h3 id="tag">Tag</h3>
<table>
  <thead>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Content</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>m-autocomplete</code></td>
    <td>Custom Element</td>
    <td>None</td>
  </tr>
  </tbody>
</table>
<h3 id="attributes">Attributes</h3>
<table>
  <thead>
  <tr>
    <th>Name</th>
    <th>Value</th>
    <th>Required</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>source</code></td>
    <td>String</td>
    <td>Yes</td>
    <td>The source of data to query for matches. Learn how to create them <a href="#creating-sources">below</a></td>
  </tr>
  <tr>
    <td><code>max</code></td>
    <td>Number</td>
    <td></td>
    <td>Truncates the number of results to <code>max</code>. Autocomplete will overflow at about 10 visible results regardless of the max set.</td>
  </tr>
  </tbody>
</table>
<h3 id="events">Events</h3>
<table>
  <thead>
  <tr>
    <th>Name</th>
    <th>Detail</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>m-select</code></td>
    <td><code>source</code> the source name for easy reference and <code>item</code> the item selected from <code>matches</code>. Item will be the whole object as returned by the source.</td>
    <td>Fired after a match was selected by the user.</td>
  </tr>
  </tbody>
</table>
<h2 id="guidelines">Guidelines</h2>
<h3 id="creating-sources">Creating sources</h3>
<p>Sources are async functions added to the global <code>MdashAutocomplete.prototype.sources</code> object. Here's an example <code>fruit</code> source:</p>
<code-sample readonly="true" mode="javascript">
  MdashAutocomplete.prototype.sources.fruit = function (query) \{
    // Use query to fetch/filter/map/find/whatever your use case is for getting matching results
    let matches = ['apple', 'banana', 'peach'].filter(fruit => fruit.startsWith(query));

    // Function must return a Promise or use async keyword
    return Promise.resolve(\{query, matches});
  }
</code-sample>
<p>Note that an object with the original <code>query</code> must be returned to avoid showing stale matches and an Array of <code>matches</code> must be returned even if empty (Autocomplete handles that). It doesn't matter when a source is added to Autocomplete because the lookup will happen in real time.</p>
<h3 id="accessibility">Accessibility</h3>
<p></p>